---
title: "Project1"
author: "Matas Vitkauskas"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      warning = FALSE,
                      message = FALSE
                      )
```
## Project 1

The first project is designed to make you solve some programming challenges that are relevant to Computational Biology. This project will be worth 30% of your final grade and is split into three distinct parts

* Write a basic implementation of a genome assembler (by comparing suffixes and prefixes of reads) - 50%
* Write a function to backtrack through a global/local matrix - 25%
* Cut the human chromosome 22 into pieces using the HindIII restriction enzyme - 25% 

As always marks are given for coding something that works and solves the problem, and shows that you have thought about all of the issues that are involved. There are marks given for making your code easy for me to read and understand whats going on ....

### Question 1

Eureka, we have sequenced the phiX genome, we have sequenced 50bp reads and now we want to assemble it back into a full genome. We have sequenced 3000 reads from this genome - in this case all of the reads come from the same + strand and they have no sequencing errors.... (I have done this for simplicity)

```{r}
library(Biostrings)
phiXgenome = readDNAStringSet("phiX.fa")
phiXgenome_reads = readDNAStringSet("phiX_sequencing_reads.fa")
```

What is the average coverage of this sequencing experiment?
```{r}

```

Implement a greedy approach for solving the shortest common substring problem in order to assemble this genome. This will consist of several steps ... 

1. reading in all of the reads
2. for each potential pair of reads calculate the number of base pairs that overlaps between them (i.e. compare suffixes and prefixes)
3. join the reads that overlap the best together
4. iterate 2 & 3 until you this no longer works / makes sense

Depending on how you code this - it may make your computer run "hot" - it is best to test this first on a small subset of the data before doing this for the whole set. 

```{r}

```

Does the genome you have assembled differ from the real genome (in phiX.fa)? If so how?

```{r}
phiXgenome = readDNAStringSet("phiX.fa")
```


### Question 2

The function pairwiseAlignment from Bioconductor allows you to provide two differents strings and return the best global or local alignment between them. 

Smith-Waterman (local) and Needleman-Wunsch (global) both work by using dynamic programming to create matrix, which you then use to calculate the optimal alignment. Below is code for generating this matrix for each situation.

```{r globalalignment}
library(Biostrings)

X = c("T", "A", "T", "T" ,"G", "G", "C", "T", "A", "T", "A", "C", "G", "G", "T", "T")
Y = c("G", "C", "G", "T", "A", "T", "G", "C")


D = matrix(ncol = length(X)+1, nrow=length(Y)+1) #create matrix to go down x or Y string
colnames(D) = c("", X)
rownames(D) = c("", Y)
gap = -4 #set penalty for gap

mapping <- diag(4)
dimnames(mapping) <- list(DNA_BASES, DNA_BASES)
mapping[1,] = c(1,-2,-1,-2)  
mapping[2,] = c(-2,1,-2,-1)  
mapping[3,] = c(-1,-2,1,-2)  
mapping[4,] = c(-2,-1,-2,1) # A-T -2; A-G -1; A-C -2; A-A 1


D[1,] = sapply(1:ncol(D), function(x){ 0 }) #make first line 0 so that can find the first match
D[,1] = sapply(1:nrow(D), function(x){ (x-1) * gap }) #fill first column

for(i in 2:(nrow(D))){# Y
  for(j in 2:(ncol(D))){ # Y
    dv = D[i-1, j-1] + mapping[ X[j-1], Y[i-1] ] #building on top of that with the matching from mapping
    lv = D[i-1, j] + gap
    tv = D[i, j-1] + gap
    D[i,j] = max(dv, lv, tv)
  }
}

dv = D[2-1, 2-1] + mapping[ X[2-1], Y[2-1] ] 
lv = D[2-1, 2] + gap
tv = D[2, 2-1] + gap
D[2,2] = max(dv, lv, tv) #maximizing similarity
D
#1 mismatch #-1 match
```

```{r localalignment}
X = c("A", "A", "A", "A", "C", "C", "C", "C", "C", "G", "G", "G", "G", "T", "T", "A")
Y = c("T", "T", "C", "C", "C", "G", "G", "G", "A", "A", "C", "C", "A", "A", "C", "C")

D = matrix(ncol = length(X)+1, nrow=length(Y)+1)
colnames(D) = c("", X)
rownames(D) = c("", Y)

gap = -4

mapping <- diag(4)
dimnames(mapping) <- list(DNA_BASES, DNA_BASES)
mapping[1,] = c(1,-2,-1,-2)  
mapping[2,] = c(-2,1,-2,-1)  
mapping[3,] = c(-1,-2,1,-2)  
mapping[4,] = c(-2,-1,-2,1)  

D[1,] = sapply(1:ncol(D), function(x){ 0 })
D[,1] = sapply(1:nrow(D), function(x){ 0 })

for(i in 2:(nrow(D))){# Y
  for(j in 2:(ncol(D))){ # Y
    dv = D[i-1, j-1] + mapping[ X[j-1], Y[i-1] ]
    lv = D[i-1, j] + gap
    tv = D[i, j-1] + gap
    D[i,j] = max(0, dv, lv, tv) #make sure that does not go below 0
  }
}
D
```

Write two functions _backtrace_local_ and _backtrace_global_ that takes a matrix generated by local or global alignment (respectively) and returns the optimal alignment between the two (i.e. the result should look something like the result from pairwiseAlignment....

```{r}
foo = pairwiseAlignment(paste(X, collapse=""), paste(Y, collapse=""), type = "local")
c(alignedPattern(foo), alignedSubject(foo))
```

```{r backtracking local agorithm}

backtrace_local = function(d_mat){
  #Creting an empty vector to store the string
  alignment <- c()
  #selecting the maximum number(seed) in the matrix
  max(D)
  seed_index <- which(D == max(D), arr.ind = TRUE) #gives row and col
  i <- seed_index[1] #select row #9
  j <- seed_index[2] #select column #13
  d <- D[i,j] #seed score 

  #getting the letter
  colnames(D)[j] #select the last basepair from the aligned sequence
  alignment <- append(alignment, colnames(D)[j])
  
  #local backtracking algorithm
  while (d != 1) {
    i = i-1
    j = j-1
    d <- D[i,j]
    alignment <- append(alignment, colnames(D)[j])
    }

  #reverse the vector
  strReverse <- function(x)
        sapply(lapply(strsplit(x, NULL), rev), paste, collapse="")
  alignment <- strReverse(paste(alignment, collapse = ""))

  # format the output to fit pairwiseAlignment function
  seq1 <- DNAString(x = alignment)
  seq2 <- DNAString(x = alignment)
  myseqs <- c(DNAStringSet(seq1), DNAStringSet(seq2))
  return(myseqs)
}

backtrace_local(D)

```

```{r}
foo = pairwiseAlignment(paste(X, collapse=""), paste(Y, collapse=""), type = "global", gapOpening = 0, gapExtension = 4, substitutionMatrix= mapping)
c(alignedPattern(foo), alignedSubject(foo))
```

```{r global alignment}
backtrace_global = function(d_mat){
  #Creting an empty vector to store the string
  alignment_ref <- c()
  alignment_pat <- c()
  #selecting the maximum number(seed) in the global alignment matrix

  i <- nrow(D) #gives last row number
  j <- which(D[nrow(D),] == max(D[nrow(D),]), arr.ind = TRUE)[[1]] #gives column number
  j_max <- which(D[nrow(D),] == max(D[nrow(D),]), arr.ind = TRUE)[[1]] +1 #used in adding base pairs upstream of   aligned base pair
  d <- D[i,j] #seed score

  #getting initial letter
  colnames(D)[j] #select the last basepair from the aligned sequence
  alignment_ref <- append(alignment_ref, colnames(D)[j])
  rownames(D)[i]
  alignment_pat <- append(alignment_pat, rownames(D)[i])

  #Initializing the algorythm

  l <- D[i, j-1] #to the left
  diag <- D[i-1, j-1] # to the diagonal
  a <- D[i-1, j] #to above
  count <- nrow(D) #length of pattern sequence

  while (count != 2) { # stop at row two
  l <- D[i, j-1] #to the left
  diag <- D[i-1, j-1] # to the diagonal
  a <- D[i-1, j] #to above
  if (d-l == -4) {
   #gap left
    i = i
    j = j-1
    d <- D[i,j]
    alignment_pat <- append(alignment_pat, "-")
    alignment_ref <- append(alignment_ref, colnames(D)[j])
  } else if (d-a == -4){
    #gap above
    i = i-1
    j = j
    d <- D[i,j]
    alignment_ref <- append(alignment_ref, "-")
    alignment_pat <- append(alignment_pat, rownames(D)[i])
    count <- count - 1
  } else if (d-diag == 1 | -1){
     #match/mismatch
    i = i-1
    j = j-1
    d <- D[i,j]
    alignment_ref <- append(alignment_ref, colnames(D)[j])
    alignment_pat <- append(alignment_pat, rownames(D)[i])
    count <- count - 1
  }
}

  #reverse the vector
  strReverse <- function(x)
        sapply(lapply(strsplit(x, NULL), rev), paste, collapse="")
  alignment_ref <- strReverse(paste(alignment_ref, collapse = ""))
  alignment_pat <- strReverse(paste(alignment_pat, collapse = ""))



  # Assembling reference sequence
  ref_seq1 <- colnames(D)[3:j-1]
  ref_seq <- append(ref_seq1, alignment_ref) 
  ref_seq2 <- colnames(D)[j_max:ncol(D)] #j_max = j of seed + 1 to get base pairs upstream of start location
  ref_seq <- append(ref_seq, ref_seq2)
  ref_seq <- paste(ref_seq, collapse = "")

  ref_seq

  # Assembling pattern sequence
  p_seq <- c()
  for (a in 1:length(ref_seq1)){ #appends beginning
    p_seq <- append(p_seq, "-")
  }
  p_seq <- append(p_seq,alignment_pat) # add pattern sequence

  for (b in 1:length(ref_seq2)) { #appends surplus of base pairs
    p_seq <- append(p_seq, "-")
  }
  p_seq <- paste(p_seq, collapse = "")
  #Adding the sequences together

  myseqs <- DNAStringSet(c(ref_seq, p_seq))
  return(myseqs)
}

backtrace_global(D)
```


```


### Question 3

Restriction enzymes are proteins that preferentially cut DNA sequence at specific patterns of nucleotides. 

HindIII preferentially recognises sequences that looks like this: 

5' AAGCTT
3' TTCGAA

And cuts them like this ....
5' ---A   AGCTT--- 3'
3' ---TTCGA   A--- 5' 

How many potential HindIII recognition sites are there in the human genome (i.e. chrs1-22, X and Y).

```{r}
library(BSgenome.Hsapiens.UCSC.hg38)

count <- 0
for (i in 1:24){
  a <- vmatchPattern(pattern = "AAGCTT", subject = as.character(Hsapiens[[i]]))
  a <- length(a[[1]]) * 2 
  count <- count + a
}

```

Write a piece of code that takes human chr22 and cuts it into sequences at the HindIII recognition site...
ie. 

_AGGGTGTGGGAAGCTTTGCCCGGGG_

would give

_AGGGTGTGGGA_

and 

_AGCTTTGCCCGGGG_


```{r}
b <- vmatchPattern(pattern = "AAGCTT", subject = as.character(Hsapiens[[22]])) #I get 8676 matches, but my cuts are 2000 more

b
b[[1]] #to select IRanges object
b[[1]][1] #first entry
start(b[[1]][1]) #start index
first_cut <- extractAt(Hsapiens[[22]], IRanges(start=1, end = start(b[[1]][1]))+1) #first cut
first_cut

b[[1]][8676]
start(b[[1]][8676]) #last match index
last_cut <- extractAt(Hsapiens[[22]], IRanges(start=start(b[[1]][8676])+1, end = 50818468)) #last cut

extractAt(Hsapiens[[22]], IRanges(start= start(b[[1]][1])+1, end = start(b[[1]][2])+1))

Hind3_cuts <- DNAStringSet()
Hind3_cuts <- append(Hind3_cuts, first_cut)

for (i in 1:8675){ #-1 because the last cut is done
  cut <- extractAt(Hsapiens[[22]], IRanges(start= start(b[[1]][i])+1, end = start(b[[1]][i+1])+1))
  Hind3_cuts <- append(Hind3_cuts, cut)
}
Hind3_cuts <- append(Hind3_cuts, last_cut)
Hind3_cuts
```

While we haven't discussed this function in class - you are not allowed to use the _gaps_ function to accomplish this and you are not allowed to use functions from existing libraries to do this (i.e. in case you find something in a BioC package somewhere).


```{r}


```

As always I have office hours for a reason - and ask me if you need any clarifications - DON'T BE A MUPPET

```{r}
sessionInfo()
```